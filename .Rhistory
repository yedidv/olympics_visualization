HML = ff[4],
HML_Dummies = ff_dummies[4],
CAPM_LargeDodd_Dummies = capm_dummies[3],
FF_LargeDodd_Dummies = ff_dummies[5],
IsLargeBanks = large_bank_dummy,
CAPM_Large_Dummies = capm_dummies[4],
FF_Large_Dummies = ff_dummies[6],
CAPM_Dodd_Dummies = capm_dummies[5],
FF_Dodd_Dummies = ff_dummies[7],
)
## Find the p values for all the regressions
ff_dummy_intercept_p <- as.numeric(summary(lm(
Excess_Rets ~ mkt_rf + smb + hml + LargeDoddDummy+
LargeDummy + DoddFrankDummy,
data = subset_ticker))$coefficients[,4][1])
ff_dummy_market_return_p <- as.numeric(summary(lm(
Excess_Rets ~ mkt_rf + smb + hml + LargeDoddDummy+
LargeDummy + DoddFrankDummy,
data = subset_ticker))$coefficients[,4][2])
ff_dummy_dummy_p <- as.numeric(summary(lm(
Excess_Rets ~ mkt_rf + smb + hml + LargeDoddDummy + LargeDummy + DoddFrankDummy,
data = subset_ticker))$coefficients[,4][5])
print(ff_dummy_dummy_p)
ff_intercept_p <- as.numeric(summary(lm(
Excess_Rets ~ mkt_rf + smb + hml,
data = subset_ticker))$coefficients[,4][1])
ff_market_return_p <- as.numeric(summary(lm(
Excess_Rets ~ mkt_rf + smb + hml,
data = subset_ticker))$coefficients[,4][2])
capm_intercept_p <- as.numeric(summary(lm(Excess_Rets - risk_free ~ mkt_rf,
data = subset_ticker) )$coefficients[,4][1])
capm_market_returns_p <- as.numeric(summary(lm(Excess_Rets - risk_free ~ mkt_rf,
data = subset_ticker) )$coefficients[,4][2])
capm_dummy_intercept_p <- as.numeric(summary(lm(Excess_Rets - risk_free ~
mkt_rf + LargeDoddDummy,
#+ LargeDummy + DoddFrankDummy,
data = subset_ticker) )$coefficients[,4][1])
capm_dummy_market_returns_p <- as.numeric(summary(lm(Excess_Rets - risk_free ~ mkt_rf +
LargeDoddDummy + LargeDummy +  DoddFrankDummy,
data = subset_ticker) )$coefficients[,4][2])
capm_dummy_dummy_p <-as.numeric(summary(lm(Excess_Rets - risk_free ~ mkt_rf  +
LargeDoddDummy + LargeDummy +
DoddFrankDummy,
data = subset_ticker) )$coefficients[,4][3])
panel_p <- panel_p %>% add_row(
Name = tic,
CAPM_Intercept = capm_intercept_p,
CAPM_Intercept_Dummies = capm_dummy_intercept_p,
FF_Intercept = ff_intercept_p,
FF_Intercept_Dummies = ff_dummy_intercept_p,
CAPM_Market_Rets = capm_market_returns_p,
CAPM_Market_Rets_Dummies = capm_dummy_market_returns_p,
FF_Market_Rets = ff_market_return_p,
FF_Market_Rets_Dummies = ff_dummy_market_return_p,
CAPM_LargeDodd_Dummies = capm_dummy_dummy_p,
FF_LargeDodd_Dummies = ff_dummy_dummy_p,
IsLargeBank = large_bank_dummy
)
}
## Plot the intercepts for the CAPM, dummies and no dummies
Model_Intercept <- ggplot(data = panel, guide = T) +
geom_line(aes(x = Name, y = CAPM_Intercept, group = 1,color = 'Blue')) +
geom_line(aes(x = Name, y = CAPM_Intercept_Dummies, color = 'Green', group = 1)) +
geom_line(aes(x = Name, y = FF_Intercept, color = 'Red', group = 1) )+
geom_line(aes(x = Name, y = FF_Intercept_Dummies, group = 1, color = 'Purple')) +
scale_color_discrete(name = 'Pricing Models', labels = c('CAPM', 'CAPM Dummies',
'FF', 'FF Dummies')) +
ggtitle('Intercepts For Pricing Models') +
labs(y = 'Pricing Model Intercept', x = 'Bank Holding Company (Large Caps Shown)')  +
scale_x_discrete(guide = guide_axis(n.dodge = 10))
Model_Intercept
## plot the Excess Market Returns
Model_Excess_Market <-ggplot(data = panel, guide = T) +
geom_line(aes(x = Name, y = CAPM_Market_Rets, group = 1,color = 'Blue')) +
geom_line(aes(x = Name, y = CAPM_Market_Rets_Dummies, color = 'Green', group = 1)) +
geom_line(aes(x = Name, y = FF_Market_Rets, color = 'Red', group = 1) )+
geom_line(aes(x = Name, y = FF_Market_Rets_Dummies, group = 1, color = 'Purple')) +
scale_color_discrete(name = 'Pricing Models', labels = c('CAPM', 'CAPM Dummies',
'FF', 'FF Dummies')) +
ggtitle('Excess Market Returns For Pricing Models') +
labs(y = 'Pricing Model Excess Market Returns Coefficient', x = 'Bank Holding Company') +
scale_x_discrete(guide = guide_axis(n.dodge = 10))
Model_Excess_Market
##Plot the SMB
Model_SMB <-ggplot(data = panel, guide = T) +
geom_line(aes(x = Name, y = SMB, color = 'Red', group = 1) )+
geom_line(aes(x = Name, y = SMB_Dummies, group = 1, color = 'Purple')) +
scale_color_discrete(name = 'Pricing Models',
labels = c('FF', 'FF Dummies')) +
ggtitle('SMB For Pricing Models') +
labs(y = 'Pricing Model SMB Coefficient', x = 'Bank Holding Company') +
scale_x_discrete(guide = guide_axis(n.dodge = 10))
Model_SMB
## Plot the HML
Model_HML <-ggplot(data = panel, guide = T) +
geom_line(aes(x = Name, y = HML, color = 'Red', group = 1) )+
geom_line(aes(x = Name, y = HML_Dummies, group = 1, color = 'Purple')) +
scale_color_discrete(name = 'Pricing Models', labels = c(
'FF', 'FF Dummies')) +
theme(axis.text.x = element_blank()) + ggtitle('HML For Pricing Models') +
labs(y = 'Pricing Model HML Coefficient', x = 'Bank Holding Company') +
scale_x_discrete(labels = c(' ', 'SC'))
Model_HML
## Plot the Dummies, delete regeional banks where this doesn't apply
Model_Dummies <-ggplot(data = panel, guide = T) +
geom_point(aes(x = Name, y = CAPM_LargeDodd_Dummies, color = 'Green', group = 1)) +
geom_point(aes(x = Name, y = FF_LargeDodd_Dummies, group = 1, color = 'Purple')) +
scale_color_discrete(name = 'Pricing Models', labels = c('CAPM Dummies', 'FF Dummies')) +
ggtitle('Dodd Frank * Large Cap Dummy Variable For Pricing Models') +
labs(y = 'Dodd Frank * Large Cap Dummy Variable Coefficient',
x = 'Bank Holding Company') +
scale_x_discrete(guide = guide_axis(n.dodge = 10))
Model_Dummies
## Plot the Large Cap Frank Dummies
Model_Dodd_Dummies <- ggplot(data = panel, guide = T) +
geom_point(aes(x = Name, y = CAPM_Large_Dummies, group = 1, color= 'Green')) +
geom_point(aes(x = Name, y = FF_Large_Dummies, group = 1, color = 'Purple')) +
scale_color_discrete(name = 'Pricing Models', labels = c('CAPM Dummies',
'FF Dummies')) +
ggtitle('Large Cap Dummy Variable') +
labs(y = 'Large Cap Coefficient', x = 'Bank Holding Company') +
scale_x_discrete(guide = guide_axis(n.dodge = 10))
Model_Dodd_Dummies
## Find the mean of the p values for the regression.
## Comparing if the coefficients are significantly different
## from 0
mean_panel_p <- panel_p %>%
group_by(groups = 1) %>%
summarize_at(vars(-Name), mean)
## Mean p values, split by large and small banks
mean_small_large_panel_p <- panel_p %>%
group_by(groups = IsLargeBank) %>%
summarize_at(vars(-Name), mean)
mean_panel_p
##Read in the banks data
banks_returns <- read_excel('Returns.xlsx', sheet = 'Banks_Data') %>%
## We want to see all the distinct tickers for each year,
## along with their banks mean assets.
distinct(ticker, bank_meanAssets) %>%
## Create a dummy variable that outputs 1 if the bank is Large Cap
## (Greater than 50Billion) and 0 if it is regional
## (Greater than 10Billion, Less than 50Billion)
group_by(LargeBankDummy = ifelse(bank_meanAssets >= 50, 1, 0) ) %>%
## Keep just the ticker and the dummy variable
select(ticker, LargeBankDummy) %>%
## Remove duplicates
distinct(ticker)
## Read in the log returns
log_returns <- read_excel('Returns.xlsx',
sheet = 'No_Nulls_Log_Returns')[-c(1,2), ] %>%
##Convert to date format
mutate(Date = ymd(as.character((as.Date(as.numeric(Date),
origin = '1899-12-30') )))) %>%
## We are trying to find monthly log returns given
## daily log returns. In order to do this, we just need to
## find the sum of the log returns within each month.
mutate_at(vars(-Date), as.numeric) %>%
mutate(YM = format(Date, '%Y-%m')) %>%
group_by(YM) %>%
summarize_at(vars(-Date), sum)
setwd("~/Desktop/msba/fall2020/econometrics_final_project")
## Read in the log returns
log_returns <- read_excel('Returns.xlsx',
sheet = 'No_Nulls_Log_Returns')[-c(1,2), ] %>%
##Convert to date format
mutate(Date = ymd(as.character((as.Date(as.numeric(Date),
origin = '1899-12-30') )))) %>%
## We are trying to find monthly log returns given
## daily log returns. In order to do this, we just need to
## find the sum of the log returns within each month.
mutate_at(vars(-Date), as.numeric) %>%
mutate(YM = format(Date, '%Y-%m')) %>%
group_by(YM) %>%
summarize_at(vars(-Date), sum)
## Read in the Fama French Factors
fama_french <- read_excel('fama_factors.xlsx') %>%
## Convert to numeric
mutate_all(as.numeric) %>%
## Extract year
mutate(year = year(ym(Date))) %>%
##Create a Dodd Frank Variable that outputs 1 if 2011 or later
## and 0 if earlier than 2011.
group_by(DoddFrankDummy = ifelse(year >= 2011, 1, 0) ) %>%
## Convert to date format for joining
mutate(YM = format(ym(Date), '%Y-%m')) %>%
## Convert the Fama French Factors from percent to decimal
mutate_at(vars(`Mkt-RF`, SMB, HML, RF),
function(x){return(x/100) }) %>%
## Rename the risk free column
rename(risk_free = RF,
mkt_rf = `Mkt-RF`,
smb = SMB,
hml = HML) %>%
## inner join the log returns by date. this ensures that the fama factors
## only appear on dates where there are log returns (no holidays, etc)
inner_join(log_returns, by = 'YM')
setwd("~/Desktop/econometrics_final_project")
library(tidyverse)
library(readxl)
library(lubridate)
library(fGarch)
library(rugarch)
library(dplyr)
library(plm)
Arch_1 <- function(log_returns, ticker_names_unique) {
## Create the Arch(1) table
arch_1 <- tibble(
Date = log_returns$Date
)
archspecs <- ugarchspec(mean.model = list(armaOrder = c(1,0)))
for(tic in ticker_names_unique){
volatility <- ugarchfit(spec = archspecs, data = log_returns[[tic]])
arch_1[[tic]] <- volatility@fit$sigma
}
return(arch_1)
}
Garch_1_1 <- function(log_returns, ticker_names_unique){
## Create the Garch(1,1) table
garch_1_1 <- tibble(
date = log_returns$Date
)
for (tic in ticker_names_unique){
garch_1_1[[tic]] <- garchFit(formula = ~garch(1,1),
data = log_returns[[tic]])@sigma.t
}
return(garch_1_1)
}
ArchGarch <- function(log_returns, ticker_names_unique){
## Create the AR + GARCH model
archgarch_1_1 <- tibble(
Date = log_returns$Date
)
archgarchspecs <- ugarchspec(
variance.model = list(model = 'sGARCH', garchOrder = c(1,1)),
mean.model = list(armaOrder = c(1,0), archm = T, archpow = 2),
distribution.model = 'std')
for (tic in ticker_names_unique){
archgarchfit <- ugarchfit(spec = archgarchspecs,
data = log_returns[[tic]])
archgarch_1_1[[tic]] <- archgarchfit@fit$sigma
}
return(archgarch_1_1)
}
Format <- function(volatility) {
## Format the data
## Annualize the volatility
## average volatility for each quarter.
a <- volatility %>%
group_by(Quarter = quarter(ymd(Date), with_year = T)) %>%
summarize_at(vars(-Date), mean)
return(a)
}
##Read in the banks data
bank_returns <- read_excel('Returns.xlsx', sheet = 'Banks_Data') %>%
## We want to see all the distinct tickers for each year,
## along with their banks mean assets.
distinct(ticker, bank_meanAssets) %>%
## Create a dummy variable that outputs 1 if the bank is Large Cap
## (Greater than 50Billion) and 0 if it is regional
## (Greater than 10Billion, Less than 50Billion)
group_by(LargeBankDummy = ifelse(bank_meanAssets >= 50, 1, 0) ) %>%
## Keep just the ticker and the dummy variable
select(ticker, LargeBankDummy) %>%
## Remove duplicates
distinct(ticker)
## Read in the log returns
log_returns <- read_excel('Returns.xlsx',
sheet = 'No_Nulls_Log_Returns')[-c(1,2), ] %>%
##Convert to date format
mutate(Date = ymd(as.character((as.Date(as.numeric(Date),
origin = '1899-12-30') )))) %>%
## We are trying to find monthly log returns given
## daily log returns. In order to do this, we just need to
## find the sum of the log returns within each month.
mutate_at(vars(-Date), as.numeric)
## Select Randomly 3 models to find the order of the test.
## WFC, AIG, FBP were arbitrarily chosen to determine the order
## for this test.
acf(log_returns$FBP, main = 'FBP ACF')
acf((log_returns$FBP) ^2, main = 'FBP^2 ACF')
pacf(log_returns$FBP, main = 'FBP PACF')
pacf((log_returns$FBP)^2, main = 'FBP^2 PACF')
## The FBP determines a (1,2) model
acf(log_returns$AIG, main = 'AIG ACF')
acf((log_returns$AIG)^2, main = 'AIG^2 ACF')
pacf(log_returns$AIG, main = 'AIG PACF')
pacf((log_returns$AIG)^2, main = 'AIG^2 PACF')
## AIG determines a (1,2) model
acf(log_returns$FULT, main = 'FULT ACF')
acf((log_returns$FULT)^2, main = 'FULT^2 ACF')
pacf(log_returns$FULT, main = 'FULT PACF')
pacf((log_returns$FULT)^2, main = 'FULT^2 PACF')
## FULT determines a (1,1) model
## We are going to generate an ARCH(1) model,
## A Garch(1,2) model,
## And a AR(1) + Garch(1,1) model
ticker_names_unique <- unique(names(log_returns[-c(1)]))
## Create the Arch(1) table
arch1 <- Arch_1(log_returns, ticker_names_unique)
## Create the Garch(1,1) table
garch11 <- Garch_1_1(log_returns, ticker_names_unique) %>%
rename(Date = date)
garch11 %>% group_by(year = year(ymd(Date)))
## Create a Arch(1) + Garch(1,1)
archgarch11 <- ArchGarch(log_returns, ticker_names_unique)
saveRDS(arch1, file = 'arch1.rds')
saveRDS(garch11, file = 'garch11.rds')
saveRDS(archgarch11, file = 'archgarch11.rds')
arch_1 <- Format(arch1)
garch_1_1 <- Format(garch11)
archgarch_1_1 <- Format(archgarch11)
Panel <- function(volatility_model, ticker_names_unique, bank_returns){
panel <- tibble(Quarter = numeric(),
Bank = character(),
volatility = numeric(),
LargeDummy = numeric())
for (tic in ticker_names_unique){
large_bank_dummy <- subset.data.frame(bank_returns, ticker == tic) %>%
pull(LargeBankDummy)
subset_df <- volatility_model[,c(tic, 'Quarter')] %>%
add_column(LargeDummy = large_bank_dummy)
panel <- panel %>%
add_row(
Quarter = subset_df$Quarter,
volatility = subset_df[[tic]],
LargeDummy = subset_df$LargeDummy,
Bank = tic
)
}
return(panel %>% mutate(date = yq(Quarter)) %>%
select(-Quarter))
}
## Panel data
arch_1_panel <- Panel(arch_1, ticker_names_unique, bank_returns)
arch_panel <- pdata.frame(arch_1_panel, index = c('date', 'Bank'))
pdim(arch_panel)
summary(plm(volatility ~ LargeDummy,
data = arch_panel, model = 'within') )
glimpse(arch_1_panel)
library(glmnet)
install.packages('glmnet')
install.packages('plotly')
install.packages('tidyverse')
## Bisection Method Function
Bisection <- function(fun, ## Call the f(x) functions
a, ## left point for bisection
b, ## right point for bisection
tol = 1e-6, ## tolerance between a and b
maxN = 200 ## we want to have a max on iterations
## if no solution we don't want a
## data leak
){
## Check and make sure x* is between a and b
fa <- fun(a)
fb <- fun(b)
if (fa * fb > 0){
stop('The solution is not between the bounds [a,b].
Widen the search')
}
## Check if c = x*
c <- (a + b) / 2
fc <- fun(c)
if ( abs(fc) < tol | abs(a - b) < tol){
return(c)
}
## Main loop
for( i in 1:maxN){ ## We don't want the loop to be infinite
if(fc * fa < 0){
## Left side
b <- c
fb <- fc
}
else{
## Right side
a <- c
fa <- fc
}
if ( abs(fc) < tol | abs(a - b) < tol){
message(sprintf('Solution achieved in %d iterations', i))
message(sprintf('\tx = %5.4f', c))
message(sprintf('\tf(x*) = %5.4f', fc))
return(c)
}
c <- (a + b) / 2
fc <- fun(c)
}
message(print('No Solution found'))
}
library(Matrix)
library(tidyverse)
## Name the function
Fun1<- function(x){
return(x^3 + 3 * x^2 - 2*x + 4)
}
## Define the x variables
x <- seq(-4, 1, length(500))
Bisection(Fun1, min(x), max(x))
answers <- tibble(x = x,
f_x = Fun1(x))
view(answers)
## Define the x variables
x <- seq(-4, 1, length = 500)
## Bisection Method Function
Bisection <- function(fun, ## Call the f(x) functions
a, ## left point for bisection
b, ## right point for bisection
tol = 1e-6, ## tolerance between a and b
maxN = 200 ## we want to have a max on iterations
## if no solution we don't want a
## data leak
){
## Check and make sure x* is between a and b
fa <- fun(a)
fb <- fun(b)
if (fa * fb > 0){
stop('The solution is not between the bounds [a,b].
Widen the search')
}
## Check if c = x*
c <- (a + b) / 2
fc <- fun(c)
if ( abs(fc) < tol | abs(a - b) < tol){
return(c)
}
## Main loop
for( i in 1:maxN){ ## We don't want the loop to be infinite
if(fc * fa < 0){
## Left side
b <- c
fb <- fc
}
else{
## Right side
a <- c
fa <- fc
}
if ( abs(fc) < tol | abs(a - b) < tol){
message(sprintf('Solution achieved in %d iterations', i))
message(sprintf('\tx = %5.4f', c))
message(sprintf('\tf(x*) = %5.4f', fc))
return(c)
}
c <- (a + b) / 2
fc <- fun(c)
}
message(print('No Solution found'))
}
Bisection(Fun1, min(x), max(x))
answers <- tibble(x = x,
f_x = Fun1(x))
view(answers)
ggplot(answers, aes(x = x, y = f_x))
ggplot(answers, aes(x = x, y = f_x)) + geom_line()
glimpse(answers)
source('~/Desktop/msba/spring2021/Fin_Computation_Simulation/homework/hw3/hw3.r')
library(tidyverse)
## Name the function
Fun1<- function(x){
return(x^3 + 3 * x^2 - 2*x + 4)
}
## Define the x variables
x <- seq(-4, 1, length = 500)
## Bisection Method Function
Bisection <- function(fun, ## Call the f(x) functions
a, ## left point for bisection
b, ## right point for bisection
tol = 1e-6, ## tolerance between a and b
maxN = 200 ## we want to have a max on iterations
## if no solution we don't want a
## data leak
){
## Check and make sure x* is between a and b
fa <- fun(a)
fb <- fun(b)
if (fa * fb > 0){
stop('The solution is not between the bounds [a,b].
Widen the search')
}
## Check if c = x*
c <- (a + b) / 2
fc <- fun(c)
if ( abs(fc) < tol | abs(a - b) < tol){
return(c)
}
## Main loop
for( i in 1:maxN){ ## We don't want the loop to be infinite
if(fc * fa < 0){
## Left side
b <- c
fb <- fc
}
else{
## Right side
a <- c
fa <- fc
}
if ( abs(fc) < tol | abs(a - b) < tol){
message(sprintf('Solution achieved in %d iterations', i))
message(sprintf('\tx = %5.4f', c))
message(sprintf('\tf(x*) = %5.4f', fc))
return(c)
}
c <- (a + b) / 2
fc <- fun(c)
}
message(print('No Solution found'))
}
Bisection(Fun1, min(x), max(x))
answers <- tibble(x = x,
f_x = Fun1(x))
ggplot(answers, aes(x = x, y = f_x)) + geom_line()
library(shiny); runApp('Desktop/msba/spring2021/applied_analytics/case_studies/olympics_visualization/exploration.R')
