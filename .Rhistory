rename(risk_free = RF,
mkt_rf = `Mkt-RF`,
smb = SMB,
hml = HML) %>%
## inner join the log returns by date. this ensures that the fama factors
## only appear on dates where there are log returns (no holidays, etc)
inner_join(log_returns, by = 'YM')
setwd("~/Desktop/econometrics_final_project")
library(tidyverse)
library(readxl)
library(lubridate)
library(fGarch)
library(rugarch)
library(dplyr)
library(plm)
Arch_1 <- function(log_returns, ticker_names_unique) {
## Create the Arch(1) table
arch_1 <- tibble(
Date = log_returns$Date
)
archspecs <- ugarchspec(mean.model = list(armaOrder = c(1,0)))
for(tic in ticker_names_unique){
volatility <- ugarchfit(spec = archspecs, data = log_returns[[tic]])
arch_1[[tic]] <- volatility@fit$sigma
}
return(arch_1)
}
Garch_1_1 <- function(log_returns, ticker_names_unique){
## Create the Garch(1,1) table
garch_1_1 <- tibble(
date = log_returns$Date
)
for (tic in ticker_names_unique){
garch_1_1[[tic]] <- garchFit(formula = ~garch(1,1),
data = log_returns[[tic]])@sigma.t
}
return(garch_1_1)
}
ArchGarch <- function(log_returns, ticker_names_unique){
## Create the AR + GARCH model
archgarch_1_1 <- tibble(
Date = log_returns$Date
)
archgarchspecs <- ugarchspec(
variance.model = list(model = 'sGARCH', garchOrder = c(1,1)),
mean.model = list(armaOrder = c(1,0), archm = T, archpow = 2),
distribution.model = 'std')
for (tic in ticker_names_unique){
archgarchfit <- ugarchfit(spec = archgarchspecs,
data = log_returns[[tic]])
archgarch_1_1[[tic]] <- archgarchfit@fit$sigma
}
return(archgarch_1_1)
}
Format <- function(volatility) {
## Format the data
## Annualize the volatility
## average volatility for each quarter.
a <- volatility %>%
group_by(Quarter = quarter(ymd(Date), with_year = T)) %>%
summarize_at(vars(-Date), mean)
return(a)
}
##Read in the banks data
bank_returns <- read_excel('Returns.xlsx', sheet = 'Banks_Data') %>%
## We want to see all the distinct tickers for each year,
## along with their banks mean assets.
distinct(ticker, bank_meanAssets) %>%
## Create a dummy variable that outputs 1 if the bank is Large Cap
## (Greater than 50Billion) and 0 if it is regional
## (Greater than 10Billion, Less than 50Billion)
group_by(LargeBankDummy = ifelse(bank_meanAssets >= 50, 1, 0) ) %>%
## Keep just the ticker and the dummy variable
select(ticker, LargeBankDummy) %>%
## Remove duplicates
distinct(ticker)
## Read in the log returns
log_returns <- read_excel('Returns.xlsx',
sheet = 'No_Nulls_Log_Returns')[-c(1,2), ] %>%
##Convert to date format
mutate(Date = ymd(as.character((as.Date(as.numeric(Date),
origin = '1899-12-30') )))) %>%
## We are trying to find monthly log returns given
## daily log returns. In order to do this, we just need to
## find the sum of the log returns within each month.
mutate_at(vars(-Date), as.numeric)
## Select Randomly 3 models to find the order of the test.
## WFC, AIG, FBP were arbitrarily chosen to determine the order
## for this test.
acf(log_returns$FBP, main = 'FBP ACF')
acf((log_returns$FBP) ^2, main = 'FBP^2 ACF')
pacf(log_returns$FBP, main = 'FBP PACF')
pacf((log_returns$FBP)^2, main = 'FBP^2 PACF')
## The FBP determines a (1,2) model
acf(log_returns$AIG, main = 'AIG ACF')
acf((log_returns$AIG)^2, main = 'AIG^2 ACF')
pacf(log_returns$AIG, main = 'AIG PACF')
pacf((log_returns$AIG)^2, main = 'AIG^2 PACF')
## AIG determines a (1,2) model
acf(log_returns$FULT, main = 'FULT ACF')
acf((log_returns$FULT)^2, main = 'FULT^2 ACF')
pacf(log_returns$FULT, main = 'FULT PACF')
pacf((log_returns$FULT)^2, main = 'FULT^2 PACF')
## FULT determines a (1,1) model
## We are going to generate an ARCH(1) model,
## A Garch(1,2) model,
## And a AR(1) + Garch(1,1) model
ticker_names_unique <- unique(names(log_returns[-c(1)]))
## Create the Arch(1) table
arch1 <- Arch_1(log_returns, ticker_names_unique)
## Create the Garch(1,1) table
garch11 <- Garch_1_1(log_returns, ticker_names_unique) %>%
rename(Date = date)
garch11 %>% group_by(year = year(ymd(Date)))
## Create a Arch(1) + Garch(1,1)
archgarch11 <- ArchGarch(log_returns, ticker_names_unique)
saveRDS(arch1, file = 'arch1.rds')
saveRDS(garch11, file = 'garch11.rds')
saveRDS(archgarch11, file = 'archgarch11.rds')
arch_1 <- Format(arch1)
garch_1_1 <- Format(garch11)
archgarch_1_1 <- Format(archgarch11)
Panel <- function(volatility_model, ticker_names_unique, bank_returns){
panel <- tibble(Quarter = numeric(),
Bank = character(),
volatility = numeric(),
LargeDummy = numeric())
for (tic in ticker_names_unique){
large_bank_dummy <- subset.data.frame(bank_returns, ticker == tic) %>%
pull(LargeBankDummy)
subset_df <- volatility_model[,c(tic, 'Quarter')] %>%
add_column(LargeDummy = large_bank_dummy)
panel <- panel %>%
add_row(
Quarter = subset_df$Quarter,
volatility = subset_df[[tic]],
LargeDummy = subset_df$LargeDummy,
Bank = tic
)
}
return(panel %>% mutate(date = yq(Quarter)) %>%
select(-Quarter))
}
## Panel data
arch_1_panel <- Panel(arch_1, ticker_names_unique, bank_returns)
arch_panel <- pdata.frame(arch_1_panel, index = c('date', 'Bank'))
pdim(arch_panel)
summary(plm(volatility ~ LargeDummy,
data = arch_panel, model = 'within') )
glimpse(arch_1_panel)
library(glmnet)
install.packages('glmnet')
install.packages('plotly')
install.packages('tidyverse')
## Bisection Method Function
Bisection <- function(fun, ## Call the f(x) functions
a, ## left point for bisection
b, ## right point for bisection
tol = 1e-6, ## tolerance between a and b
maxN = 200 ## we want to have a max on iterations
## if no solution we don't want a
## data leak
){
## Check and make sure x* is between a and b
fa <- fun(a)
fb <- fun(b)
if (fa * fb > 0){
stop('The solution is not between the bounds [a,b].
Widen the search')
}
## Check if c = x*
c <- (a + b) / 2
fc <- fun(c)
if ( abs(fc) < tol | abs(a - b) < tol){
return(c)
}
## Main loop
for( i in 1:maxN){ ## We don't want the loop to be infinite
if(fc * fa < 0){
## Left side
b <- c
fb <- fc
}
else{
## Right side
a <- c
fa <- fc
}
if ( abs(fc) < tol | abs(a - b) < tol){
message(sprintf('Solution achieved in %d iterations', i))
message(sprintf('\tx = %5.4f', c))
message(sprintf('\tf(x*) = %5.4f', fc))
return(c)
}
c <- (a + b) / 2
fc <- fun(c)
}
message(print('No Solution found'))
}
library(Matrix)
library(tidyverse)
## Name the function
Fun1<- function(x){
return(x^3 + 3 * x^2 - 2*x + 4)
}
## Define the x variables
x <- seq(-4, 1, length(500))
Bisection(Fun1, min(x), max(x))
answers <- tibble(x = x,
f_x = Fun1(x))
view(answers)
## Define the x variables
x <- seq(-4, 1, length = 500)
## Bisection Method Function
Bisection <- function(fun, ## Call the f(x) functions
a, ## left point for bisection
b, ## right point for bisection
tol = 1e-6, ## tolerance between a and b
maxN = 200 ## we want to have a max on iterations
## if no solution we don't want a
## data leak
){
## Check and make sure x* is between a and b
fa <- fun(a)
fb <- fun(b)
if (fa * fb > 0){
stop('The solution is not between the bounds [a,b].
Widen the search')
}
## Check if c = x*
c <- (a + b) / 2
fc <- fun(c)
if ( abs(fc) < tol | abs(a - b) < tol){
return(c)
}
## Main loop
for( i in 1:maxN){ ## We don't want the loop to be infinite
if(fc * fa < 0){
## Left side
b <- c
fb <- fc
}
else{
## Right side
a <- c
fa <- fc
}
if ( abs(fc) < tol | abs(a - b) < tol){
message(sprintf('Solution achieved in %d iterations', i))
message(sprintf('\tx = %5.4f', c))
message(sprintf('\tf(x*) = %5.4f', fc))
return(c)
}
c <- (a + b) / 2
fc <- fun(c)
}
message(print('No Solution found'))
}
Bisection(Fun1, min(x), max(x))
answers <- tibble(x = x,
f_x = Fun1(x))
view(answers)
ggplot(answers, aes(x = x, y = f_x))
ggplot(answers, aes(x = x, y = f_x)) + geom_line()
glimpse(answers)
source('~/Desktop/msba/spring2021/Fin_Computation_Simulation/homework/hw3/hw3.r')
library(tidyverse)
## Name the function
Fun1<- function(x){
return(x^3 + 3 * x^2 - 2*x + 4)
}
## Define the x variables
x <- seq(-4, 1, length = 500)
## Bisection Method Function
Bisection <- function(fun, ## Call the f(x) functions
a, ## left point for bisection
b, ## right point for bisection
tol = 1e-6, ## tolerance between a and b
maxN = 200 ## we want to have a max on iterations
## if no solution we don't want a
## data leak
){
## Check and make sure x* is between a and b
fa <- fun(a)
fb <- fun(b)
if (fa * fb > 0){
stop('The solution is not between the bounds [a,b].
Widen the search')
}
## Check if c = x*
c <- (a + b) / 2
fc <- fun(c)
if ( abs(fc) < tol | abs(a - b) < tol){
return(c)
}
## Main loop
for( i in 1:maxN){ ## We don't want the loop to be infinite
if(fc * fa < 0){
## Left side
b <- c
fb <- fc
}
else{
## Right side
a <- c
fa <- fc
}
if ( abs(fc) < tol | abs(a - b) < tol){
message(sprintf('Solution achieved in %d iterations', i))
message(sprintf('\tx = %5.4f', c))
message(sprintf('\tf(x*) = %5.4f', fc))
return(c)
}
c <- (a + b) / 2
fc <- fun(c)
}
message(print('No Solution found'))
}
Bisection(Fun1, min(x), max(x))
answers <- tibble(x = x,
f_x = Fun1(x))
ggplot(answers, aes(x = x, y = f_x)) + geom_line()
setwd("~/Desktop/msba/spring2021/applied_analytics/case_studies/case_study_1")
#### Read in Data and packages ######
library(tidyverse)
library(plotly)
library(shiny)
source('funs.r')
## Read in both csvs, and full join them together
olympics <- read_csv('case_1_data/OlympicHistoryAthletes.csv') %>%
full_join(read_csv('case_1_data/noc_regions.csv') ) %>%
mutate(Year = as.integer(Year))
##### Format the Data ####
## In the medal category, the null values mean the player didn't win a medal
olympics <- olympics %>%
## Replace null with no_medal to show they
## didn't win anything
mutate(Medal = replace_na(Medal, 'no_medal')) %>%
## Order by year
arrange(Year)
## Create Dummy variables for the medals
olympics <- olympics %>%
## Gold, silver, bronze, and no medals are the dummy variables
mutate(gold = ifelse(Medal == 'Gold', 1, 0) ) %>%
mutate(silver = ifelse(Medal == 'Silver', 1, 0) ) %>%
mutate(no_medal = ifelse(Medal == 'no_medal', 1, 0) ) %>%
mutate(bronze = ifelse(Medal == 'Bronze', 1, 0) ) %>%
## Remove the one null year variable
filter(!is.na(Year)) %>%
mutate(region = ifelse(NOC == 'SGP', 'Singapore', region)) %>%
## We only select the columns we need
select(NOC,region, Year, Season, Sex, gold, silver, bronze, no_medal, Medal)
#### Shiny App ####
ui <- fluidPage(
## Check the Year we are looking at
sliderInput("Year", "Range", value = c(1900, 1940),
min = min(olympics$Year) ,
max = max(olympics$Year),
sep = '') ,
## Male vs Female or both
checkboxGroupInput('Sex', 'Subset Sexes',
choiceNames = c('Male', 'Female'),
choiceValues = c('M', 'F')
),
## Which Awards do we want to look at
checkboxGroupInput('Medal', 'Subset Medals',
choiceNames = c('Gold', 'Silver', 'Bronze', 'No Medal'),
choiceValues = c('Gold', 'Silver', 'Bronze', 'no_medal'))
,
mainPanel(
plotlyOutput('plot', width = '1400px', height = '1400px')
)
)
server <- function(input, output, server){
output$plot <- renderPlotly({
df <- olympics %>%
filter(Year > input$Year[1] ) %>%
filter(Year < input$Year[2]) %>%
filter(Sex %in% input$Sex) %>%
filter(Medal %in% input$Medal) %>%
group_by(NOC, region)
df <- Medal_Summary(df)
plot_ly(df,
type = 'choropleth',
locations = df$NOC,
z = df$no_medal,
text = df$region,
colorscale = 'Blues')
})
}
shinyApp(ui = ui, server = server)
ui <- fluidPage(
## Check the Year we are looking at
sliderInput("Year", "Range", value = c(1900, 1940),
min = min(olympics$Year) ,
max = max(olympics$Year),
sep = '') ,
## Male vs Female or both
checkboxGroupInput('Sex', 'Subset Sexes',
choiceNames = c('Male', 'Female'),
choiceValues = c('M', 'F')
),
## Which Awards do we want to look at
checkboxGroupInput('Medal', 'Subset Medals',
choiceNames = c('Gold', 'Silver', 'Bronze', 'No Medal'),
choiceValues = c('Gold', 'Silver', 'Bronze', 'no_medal'))
,
mainPanel(
plotlyOutput('plot', width = '1400px', height = '1400px')
)
)
setwd("~/Desktop/msba/spring2021/applied_analytics/case_studies/case_study_1")
#### Read in Data and packages ######
library(tidyverse)
library(plotly)
library(shiny)
source('funs.r')
## Read in both csvs, and full join them together
olympics <- read_csv('case_1_data/OlympicHistoryAthletes.csv') %>%
full_join(read_csv('case_1_data/noc_regions.csv') ) %>%
mutate(Year = as.integer(Year))
## In the medal category, the null values mean the player didn't win a medal
olympics <- olympics %>%
## Replace null with no_medal to show they
## didn't win anything
mutate(Medal = replace_na(Medal, 'no_medal')) %>%
## Order by year
arrange(Year)
#### Read in Data and packages ######
library(tidyverse)
library(plotly)
library(shiny)
source('funs.r')
## Read in both csvs, and full join them together
olympics <- read_csv('case_1_data/OlympicHistoryAthletes.csv') %>%
full_join(read_csv('case_1_data/noc_regions.csv') ) %>%
mutate(Year = as.integer(Year))
setwd("~/Desktop/msba/spring2021/applied_analytics/case_studies/olympics_visualization")
setwd("~/Desktop/msba/spring2021/applied_analytics/case_studies/olympics_visualization")
#### Read in Data and packages ######
library(tidyverse)
library(plotly)
library(shiny)
source('funs.r')
## Read in both csvs, and full join them together
olympics <- read_csv('case_1_data/OlympicHistoryAthletes.csv') %>%
full_join(read_csv('case_1_data/noc_regions.csv') ) %>%
mutate(Year = as.integer(Year))
## Create Dummy variables for the medals
olympics <- olympics %>%
## Gold, silver, bronze, and no medals are the dummy variables
mutate(gold = ifelse(Medal == 'Gold', 1, 0) ) %>%
mutate(silver = ifelse(Medal == 'Silver', 1, 0) ) %>%
mutate(no_medal = ifelse(Medal == 'no_medal', 1, 0) ) %>%
mutate(bronze = ifelse(Medal == 'Bronze', 1, 0) ) %>%
## Remove the one null year variable
filter(!is.na(Year)) %>%
mutate(region = ifelse(NOC == 'SGP', 'Singapore', region)) %>%
## We only select the columns we need
select(NOC,region, Year, Season, Sex, gold, silver, bronze, no_medal, Medal)
## In the medal category, the null values mean the player didn't win a medal
olympics <- olympics %>%
## Replace null with no_medal to show they
## didn't win anything
mutate(Medal = replace_na(Medal, 'no_medal')) %>%
## Order by year
arrange(Year)
shinyApp(ui = ui, server = server)
ui <- fluidPage(
## Check the Year we are looking at
sliderInput("Year", "Range", value = c(1900, 1940),
min = min(olympics$Year) ,
max = max(olympics$Year),
sep = '') ,
## Male vs Female or both
checkboxGroupInput('Sex', 'Subset Sexes',
choiceNames = c('Male', 'Female'),
choiceValues = c('M', 'F')
),
## Which Awards do we want to look at
checkboxGroupInput('Medal', 'Subset Medals',
choiceNames = c('Gold', 'Silver', 'Bronze', 'No Medal'),
choiceValues = c('Gold', 'Silver', 'Bronze', 'no_medal'))
,
mainPanel(
plotlyOutput('plot', width = '1400px', height = '1400px')
)
)
server <- function(input, output, server){
output$plot <- renderPlotly({
df <- olympics %>%
filter(Year > input$Year[1] ) %>%
filter(Year < input$Year[2]) %>%
filter(Sex %in% input$Sex) %>%
filter(Medal %in% input$Medal) %>%
group_by(NOC, region)
df <- Medal_Summary(df)
plot_ly(df,
type = 'choropleth',
locations = df$NOC,
z = df$no_medal,
text = df$region,
colorscale = 'Blues')
})
}
runApp('exploration.R')
runApp('exploration.R')
runApp('exploration.R')
View(Medal_Summary)
runApp('exploration.R')
View(olympics)
runApp('exploration.R')
